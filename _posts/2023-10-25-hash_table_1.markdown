---
layout: post
title: 해시 테이블
date: 2023-01-18 10:09:23 +0900
category: DataStructure
tags : [DataStructure, HashTable]
comments: true
use_math: true
---

### 해시테이블이란?

데이터를 담을 테이블을 미리 크게 확보해놓은 후 입력 받은 데이터를 해싱하여 테이블 내 주소를 계산하고 이 주소에 데이터를 담는 것.

### 해시 함수란?

테이블 내의 주소를 계산하는 계산식이나 방법론

1.나눗셈법

설명
- 주소 = 입력값 % 테이블의 크기
- 보통 테이블의 크기는 소수를 쓰는 것이 공간을 효율적으로 사용할 수 있다.
- 특히 2의 제곱수와 거리가 먼 소수를 사용하는  해시 함수가 좋은 성능을 낸다. ex) 193


### 충돌(collision)

서로 다른 입력값에 대해서 해시함수의 출력인 해시값이 동일할 수 있다. 즉 입력주소가 같을 수 있으며, 이 경우를 충돌(collision)이라고한다.


### 클러스터(cluster)

똑같은 해시값이 아니더라도 헤시 테이블 내 일부 지역의 주소들을 집중적으로 반환함으로써 데이터가 한 곳에 모이는 문제인 클러스터
가 발생할 가능성이 높다.


### 자릿수 접기 (Digits Folding)

숫자를 종이를 접듯이 숫자를 접어 일정한 크기 이하의 수로 만드는 방법
ex) 8129335
- 각 자릿 수를 모두 더한다. 31 = 8 + 1 + 2 + 9 + 3 + 3 + 5
  - 이렇게 큰 숫자가 31이라는 숫자로 접힌다.
- 두 자리 씩 모두 더한다. 148 = 81 + 29 + 33 + 5
- 위의 두가지 방법 모두 일정한 범위 내의 해시값을 가질 수 있다.
  - 첫번째는 9 * 7 = 63가지의 해시값을 가질 수 있음
  - 두번째는 99 * 3 + 9 = 306개의 해시값을 가질 수 있음.
- 이 자릿수 접기는 문자열을 키로 사용하는 해시 테이블에 특히 잘 어울리는 알고리즘이다. 문자열의 각 요소를 해시 테이블로 바꾸고, 이 값을 각각 더해서 접으면 문자열을 깔끔하게 해시 테이블의 주소로 바꿀 수 있기 때문이다.

기본 알고리즘의 문제점
- 12289크기의 해시 테이블에서 10자리 글자를 각각 128개의 아스키 숫자중에 하나로 나타낸다고 하자.
- 그것에 대한 경우의 수는 127^10 = 1.091533853×10²¹이다.
- 그러나 해시값이 나올 수 있는 것은 최대 127 * 10 = 1270이다. 즉 collision이 너무너무 많이 생기게되며 테이블에서 10퍼센트만 사용하게된다.
- 그래서 해시값을 이진수로 나타낸다.
  - 이 해시값은 이진수로 나타내면, 11개의 비트만 사용한다. 즉 전체 14비트(12289 크기) 중에서 앞에서 3개의 비트는 쓰지 않는다.
  - 그래서 아래와 같이 아스키 코드를 3칸씩 `shift`연산을 하고, 각 자릿수를 더하는 방식을 취한다.
```C
int Hash(char* key, int KeyLength, int TableSize)
{
  int i = 0;
  int HashValue = 0;
  for (i = 0; i < KeyLength; i++) {
    HashValue = (HashValue << 3) + Key[i];
  }

  return HashValue % TableSize;
}
```
